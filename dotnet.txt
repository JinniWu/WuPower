1你正在开发一个自定义事件处理去自动打印所有打开的文档。事件处理可以指定要打印的份数。为此，你需要开发一个传递给事件处理程序的自定义事件参数类，你应该使用下面那个代码段？
A.public class PrintingArgs
{
    private int copies;
    public PrintingArgs(int numberOfCopies)
    {
        this.copies = numberOfCopies;
    }
    public int Copies
    {
        get { returnthis.copies; }
    }
}
B.public class PrintingArgs : EventArgs
{
    private int copies;
    public PrintingArgs(int numberOfCopies)
    {
        this.copies = numberOfCopies;
    }
    public int Copies
    {
        get { return this.copies; }
    }
}
C.public class PrintingArgs
{
    private EventArgs eventArgs;
    public PrintingArgs(EventArgs ea)
    {
        this.eventArgs = ea;
    }
    public EventArgs Args { get { return eventArgs; } }
}
D.public class PrintingArgs : EventArgs
{
    private int copies;
}
答案: B

第2题
你使用反射（Reflection）来获得方法MyMethod的信息。你需要获取MyMethod
方法是否在派生类中可以访问，你应该如何做？
A.访问MethodInfo的IsAssembly属性。
B.访问MethodInfo的IsVirtual属性。
C.访问MethodInfo的IsStatic属性。
D.访问MethodInfo的IsFamily属性。
答案: D

第3题
你正在创建一个使用非托管资源的类。这个类引用了使用托管资源的对象。你需
要确保使用这个类的用户在不需要类实例的时候能够够释放资源。你应该做那三
个工作？
（每个答案是解决方案的一部分）
A.定义一个从WeakReference继承的类。
B.定义一个实现IDisposable接口的类。
C.创建一个类析构函数，调用其它对象的方法去释放托管资源。
D.创建一个类析构函数，释放非托管资源
E.创建一个Dispose方法，调用System.GC.Collect强制垃圾回收。
F.创建一个Dispose方法，释放非托管资源并且调用其它对象的方法释放托管资
源。
答案: B, D, F
第4题
你正对一个应用进行调试。你需要找到引起异常的代码行。请问，Exception类
的哪个属性能达到这个目的？
A.Data
B.Message
C.StackTrace
D.Source
答案: C
第5题
你正在测试一个新开发的方法PersistToDB。这个方法接收一个类型为
EventLogEntry的参数，方法没有返回值。你需要创建一段代码来帮助你测试这
个方法。这段代码必须从本地计算机的应用日志读取日志项然后传递日志项给
PersistToDB方法。要求，传递到PersistToDB方法的日志项必须是MySource源
而且类型为错误或警告的日志。你应该使用下面那个代码段？
A.EventLogmyLog=newEventLog(“Application”,“.”);
foreach(EventLogEntryentryinmyLog.Entries)
{ if(entry.Source=="MySource")
{ PersistToDB(entry);
}} B.EventLogmyLog=newEventLog(“Application”,“.”);
myLog.Source=“MySource”;

foreach(EventLogEntryentryinmyLog.Entries)
{ if(entry.EntryType==(EventLogEntryType.Error&
EventLogEntryType.Warning))
{ PersistToDB(entry);
}} C.EventLogmyLog=newEventLog(“Application”,“.”);
foreach(EventLogEntryentryinmyLog.Entries)
{ if(entry.Source=="MySource")
{ if(entry.EntryType==EventLogEntryType.Error||entry.EntryType==
EventLogEntryType.Warning)
{ PersistToDB(entry);
}}} D.EventLogmyLog=newEventLog(“Application”,“.”);
myLog.Source=“MySource”;
foreach(EventLogEntryentryinmyLog.Entries)
{ if(entry.EntryType==EventLogEntryType.Error||
entry.EntryType==EventLogEntryType.Warning)
{ PersistToDB(entry);
}
答案: C
第6题
你的应用使用两个名为threadOne和threadTwo的线程。你需要修改代码使其只
有threadTwo执行完成才开始执行threadOne。你应该如何做？
A.设置threadOne运行在低优先级。
B.设置threadTwo运行在高优先级。
C.使用WaitCallback代理去同步线程。
D.调用threadOne的Sleep方法。
答案: C



第7题
你是公司A的一个开发人员。你创建了一个名为Company1的程序集。Company1
包含了一个public方法。全局程序集中包含了另一个名为Company2的程序集。
你必须保证，public方法只能够被Company2调用。你需要使用下面哪个权限类？
A.GacIdentityPermission
B.PublisherIdentityPermission
C.DataProtectionPermission
D.StrongNameIdentityPermission
答案: D
第8题
你创建了一个发送e-mail的应用。一个名称为smtp.Company.com的SMTP服务
器在本地子网是可用的。为了测试应用，你使用源地址为me@Company.com，
目标地址为you@Company.com。你应该使用下面那个代码段去发送e-mail？
A.MailAddressaddrFrom=
newMailAddress(“me@Company.com”,“Me”);MailAddressaddrTo=
newMailAddress(“you@Company.com”,“You”);MailMessagemessage=new
MailMessage(addrFrom,addrTo);message.Subject=
“Greetings!”;message.Body=
“Test”;message.Dispose();
B.stringstrSmtpClient=“mstp.Company.com”;stringstrFrom=
“me@Company.com”;
StringstrTo=“you@Company.com”;stringstrSubject=“Greetings!”;
stringstrBody=“Test”;MailMessage
msg=newMailMessage(strFrom,strTo,strSubject,strSmtpClient);
C.MailAddressaddrFrom=new
MailAddress(“me@Company.com”);MailAddressaddrTo=new
MailAddress(“you@Company.com”);MailMessagemessage=new
MailMessage(addrFrom,
addrTo);message.Subject=“Greetings!”;message.Body=“Test”;SmtpClient
client=new
SmtpClient(“smtp.Company.com”);client.Send(message);
D.MailAddressaddrFrom=
newMailAddress(“me@Company.com”,“Me”);MailAddressaddrTo=new
MailAddress(“you@Company.com”,“You”);MailMessagemessage=new
MailMessage(addrFrom,addrTo);message.Subject=
“Greetings!”;message.Body=
“Test”;SocketInformationinfo=newSocketInformation();Socketclient=new
Socket(info);System.Text.ASCIIEncodingenc=new
System.Text.ASCIIEncoding();byte[]
msgBytes=enc.GetBytes(message.ToString());client.Send(msgBytes);
答案: C



第9题
你正在开发一个自定义集合类。你需要在你的类里创建一个方法而且能够保证你
的方法的返回值是一个能够适合Foreach语句使用的类型。你应该如何实现你的
方法？
A.方法必须返回一个IEnumerator或Ienumerable的类型。
B.方法必须返回一个IComparable的类型。
C.方法必须包含一个集合。
答案: A
第10题
你正在开发一个执行数学计算的应用。你创建了一个类CalculationValues，并且
写了一个操作CalculationValues的过程PerformCalculation。你需要保证当计算
被执行的时候，用户界面能够继续响应。为此，你需要写一个代码段去调用
PerformCalculation过程去达到目的，你应该使用下面那个代码段？
A.privatevoidPerformCalculation(){...}privatevoidDoWork(){
CalculationValuesmyValues=newCalculationValues();
ThreadnewThread=newThread(
newThreadStart(PerformCalculation));
newThread.Start(myValues);}
B.privatevoidPerformCalculation(){...}privatevoidDoWork(){
CalculationValuesmyValues=newCalculationValues();
ThreadStartdelStart=new
ThreadStart(PerformCalculation);
ThreadnewThread=newThread(delStart);if(newThread.IsAlive)
{newThread.Start(myValues);}}
C.privatevoidPerformCalculation(CalculationValuesvalues){...}privatevoid
DoWork(){
CalculationValuesmyValues=newCalculationValues();
Application.DoEvents();
PerformCalculation(myValues);
Application.DoEvents();}
D.privatevoidPerformCalculation(objectvalues){...}privatevoidDoWork(){
CalculationValuesmyValues=newCalculationValues();
ThreadnewThread=newThread(
newParameterizedThreadStart(PerformCalculation));
newThread.Start(myValues);}
答案: D



第11题
你写了如下一段代码publicdelegatevoidFaxDocs(objectsender,FaxArgs
args);
你需要创建一个调用FaxDocs的事件，你应该使用那个代码段？
A.pulicstaticeventFaxDocsFax;
B.publicstaticeventFaxFaxDocs;
C.publicclassFaxArgs:EventArgs{
privatestringcoverPageInfo;
publicFaxArgs(stringcoverInfo){
this.coverPageInfo=coverPageInfo;
} publicstringCoverPageInformation{
get{returnthis.coverPageInfo;}
}}
D.publicclassFaxArgs:EventArgs{
privatestringcoverPageInfo;
publicstringCoverPageInformation{
get{returnthis.coverPageInfo;}
}}
答案: A
第12题
你写如下的代码段去调用Win32ApplicationProgrammingInterface(API)：
stringpersonName=“N?el”;
stringmsg=“Welcome”+personName+“toclub”!”;
boolrc=User32API.MessageBox(0,msg,personName,0);
为了实现上面的调用，你需要定义一个方法原型，请问，你会采用那个代码段进
行定义？
A.[DllImport("user32",CharSet=CharSet.Ansi)]
publicstaticexternboolMessageBox(inthWnd,Stringtext,Stringcaption,uint
type);}
B.[DllImport("user32",EntryPoint="MessageBoxA",CharSet=
CharSet.Ansi)]
PublicstaticexternboolMessageBox(inthWnd,
[MarshalAs(UnmanagedType.LPWStr)]Stringtext,
[MarshalAs(UnmanagedType.LPWStr)]Stringcaption,
uinttype);}
C.[DllImport("user32",CharSet=CharSet.Unicode)]



publicstaticexternboolMessageBox(inthWnd,Stringtext,Stringcaption,uint
type);}
D.[DllImport("user32",EntryPoint="MessageBoxA",CharSet=
CharSet.Unicode)]publicstaticexternboolMessageBox(inthWnd,
[MarshalAs(UnmanagedType.LPWStr)]Stringtext,



[MarshalAs(UnmanagedType.LPWStr)]Stringcaption,uinttype);}
答案: C
第13题
你需要以字符串的形式返回isolatedstorage文件内容。已知，文件名称为
Settings.dat并且在机器范围内唯一。你应该使用下面那个代码段？
A.IsolatedStorageFileStreamisoStream;isoStream=new
IsolatedStorageFileStream(
“Settings.dat”,FileMode.Open);stringresult=new
StreamReader(isoStream).ReadToEnd();
B.IsolatedStorageFileisoFile;isoFile=
IsolatedStorageFile.GetMachineStoreForAssembly();
IsolatedStorageFileStreamisoStream;isoStream=new
IsolatedStorageFileStream(
“Settings.dat”,FileMode.Open,isoFile);stringresult=new
StreamReader(isoStream).ReadToEnd();
C.IsolatedStorageFileStreamisoStream;isoStream=new
IsolatedStorageFileStream(“Settings.dat”,FileMode.Open);stringresult=
isoStream.ToString();
D.IsolatedStorageFileisoFile;isoFile=
IsolatedStorageFile.GetMachineStoreForAssembly();
IsolatedStorageFileStreamisoStream;isoStream=new
IsolatedStorageFileStream(
“Settings.dat”,FileMode.Open,isoFile);stringresult=isoStream.ToString();
答案: B
第14题
你正在写一个压缩字节数组的方法。数组被以document作为参数名传递到一个
方法。你需要压缩输入的字节数组并且返回一个字节数组作为结果。你的方法应
该使用下面那个代码段？
A.MemoryStreamstrm=newMemoryStream(document);DeflateStream
deflate=new
DeflateStream(strm,CompressionMode.Compress);byte[]result=new
byte[document.Length];deflate.Write(result,0,result.Length);returnresult;
B.MemoryStreamstrm=newMemoryStream(document);DeflateStream
deflate=new
DeflateStream(strm,
CompressionMode.Comress);deflate.Write(docemtn,0,
document.Length);deflate.Close();returnstrm.ToArray();
C.MemoryStreamstrm=newMemoryStream();DeflateStreamdeflate=new
DeflateStream(strm,CompressionMode.Compress);deflate.Write(decument,
0,
decument.Length);deflate.Close();returnstrm.ToArray();
D.MemoryStreaminStream=newMemoryStream(document);DeflateStream



deflate=
newDeflateStream(inStream,CompressionMode.Compress);MemoryStream
outStream=
newMemoryStream();intb;while((b=deflate.ReadByte())!=-1){
outStream.WriteByte((byte)b);}returnoutStream.ToArray();



答案: C
第15题
你需要选择一个类。它基于Key实现了小集合和大集合的优化。你应该选择下面
那一个类？
A.OrderedDictionaryclass
B.HybridDictionaryclass
C.ListDictionaryclass
D.Hashtableclass
答案: B
第16题
你正在写一个应用。它利用SOAP去和其他应用交换数据。你使用一个从
ArrayList继承的Department类作为数据对象发送给另一个应用。Department被
命名为dept。为了通过SOAP进行传送，你需要保证Department对象被序列化。
你应该使用下面那个代码进行dept的序列化？
A.SoapFormatterformatter=newSoapFormatter();byte[]buffer=new
byte[dept.Capacity];MemoryStreamstream=newMemoryStream(buffer);
foreach
(objectoindept){formatter.Serialize(stream,o);}
B.SoapFormatterformatter=newSoapFormatter();byte[]buffer=new
byte[dept.Capacity];MemoryStreamstream=newMemoryStream(buffer);
formatter.Serialize(stream,dept);
C.SoapFormatterformatter=newSoapFormatter();MemoryStreamstream=
new
MemoryStream();foreach(objectoindept){
Formatter.Serialize(stream,o);}
D.SoapFormatterformatter=newSoapFormatter();MemoryStreamstream=
new
MemoryStream();formatter.Serialize(stream,dept);
答案: D
第17题
你需要写一个完成如下任务的代码段:
1） 查找所有暂停的服务
2） 把服务的显示名称增加到集合中
请问，你应该使用那个代码段？
A.DimsearcherAsManagementObjectSearcher=_New
ManagementObjectSearcher(_
"Select*fromWin32_ServicewhereState='Paused'")
ForEachsvcAs



ManagementObjectInsearcher.Get()



Collection1.Add(svc("DisplayName"))
Next
B.DimsearcherAsManagementObjectSearcher=_New
ManagementObjectSearcher(_
"Select*fromWin32_Service","State='Paused'")
ForEachsvcAsManagementObjectInsearcher.Get()
Collection1.Add(svc("DisplayName"))
Next
C.DimsearcherAsManagementObjectSearcher=_New
ManagementObjectSearcher(_
"Select*fromWin32_Service")
ForEachsvcAsManagementObjectInsearcher.Get()
Ifsvc("State").ToString()="'Paused'"Then
Collection1.Add(svc("DisplayName"))
EndIf
Next
D.DimsearcherAsNewManagementObjectSearcher()searcher.Scope=
New
ManagementScope("Win32_Service")
ForEachsvcAsManagementObjectInsearcher.Get()
Ifsvc("State").ToString()="Paused"Then
Collection1.Add(svc("DisplayName"))
EndIf
Next
答案: A
第18题
你正在写一个接收字符串参数message的方法。你的方法必须截取message参
数为单独的文本行并且传递每一行给另一个方法Process。你应该使用那个代码
段？
A.DimreaderAsNew
StringReader(message)ProcessMessage(reader.ReadToEnd())reader.Close()
B.DimreaderAsNewStringReader(message)Whilereader.Peek()<>-1
DimlineasString=reader.Read().ToString()
ProcessMessage(line)EndWhilereader.Close()
C.DimreaderAsNew
StringReader(message)ProcessMessage(reader.ToString())reader.Close()
D.DimreaderAsNewStringReader(message)Whilereader.Peek()<>-1
ProcessMessage(reader.ReadLine())EndWhilereader.Close()
答案: D



第19题
你需要创建一个能够和COM进行互操作的类。为此，你需要保证COM应用能
够创建这个类的实例并且能够调用GetAddress方法。你应该使用那个代码段定
义你的类？
A.publicclassCustomer{
stringaddressString;
publicCustomer(stringaddress){addressString=address;}
publicstringGetAddress(){returnaddressString;}}
B.publicclassCustomer{
staticstringaddressString;
publicCustomer(){}
publicstaticstringGetAddress(){returnaddressString;}}
C.publicclassCustomer{
stringaddressString;
publicCustomer(){}
publicstringGetAddress(){returnaddressString;}}
D.publicclassCustomer{
stringaddressString;
publicCustomer(){}
internalstringGetAddress(){returnaddressString;}}
答案: C
第20题
你正在开发一个类库。你的代码需要访问系统环境变量。对于未给调用堆栈中处
于较高位置的所有调用方授予当前实例所指定的权限，则在运行时强制
SecurityException。你应该调用那个方法？
A.set.Demand();
B.set.Assert();
C.set.PermitOnly();
D.set.Deny();
答案: A
第21题
你正在开发一个使用安全哈希算法计算给定数据哈希值的方法。传递给你方法的
数据是一个名为message的字节数组。你需要计算输入数据的SHA1哈希值，而
且要把计算结果放入名为hash的字节数组。你应该使用下面那一个代码段？
A.SHA1sha=newSHA1CryptoServiceProvider();byte[]hash=
null;sha.TransformBlock(message,0,message.Length,hash,0);



B.SHA1sha=newSHA1CryptoServiceProvider();byte[]hash=
BitConverter.GetBytes(sha.GetHashCode());
C.SHA1sha=newSHA1CryptoServiceProvider();
byte[]hash=sha.ComputeHash(message);
D.SHA1sha=newSHA1CryptoServiceProvider();sha.GetHashCode();
byte[]hash=sha.Hash;
答案: C
第22题
你正在开发一个以后可以使用MD5算法进行验证的、计算哈希值的方法。传递
给你方法的数据是一个名为message的字节数组。你需要计算输入数据的MD5
哈希值，而且要把计算结果放入名为hash的字节数组。你应该使用下面那一个
代码段？
A.HashAlgorithmalgo=HashAlgorithm.Create(“MD5”);byte[]hash=
algo.ComputeHash(message);
B.HashAlgorithmalgo=HashAlgorithm.Create(“MD5”);byte[]hash=
BitConverter.GetBytes(algo.GetHashCode());
C.HashAlgorithmalgo;algo=
HashAlgorithm.Create(message.ToString());byte[]hash=
algo.Hash;
D.HashAlgorithmalgo=HashAlgorithm.Create(“MD5”);byte[]hash=
null;algo.TransformBlock(message,0,message.Length,hash,0);
答案: A
第23题
你需要创建一个名为MyAssembly的动态类库，同时你也需要把类库保存到磁
盘。你应该使用下面那个代码段？
A.AssemblyNamemyAssemblyName=
newAssemblyName();myAssemblyName.Name=
“MyAssembly”;AssemblyBuilder
myAssemblyBuilder=
AppDomain.CurrentDomain.DefineDynamicAssembly
(myAssemblyName,
AssemblyBuilderAccess.Run);myAssemblyBuilder.Save(“MyAssembly.dll”);
B.AssemblyNamemyAssemblyName=
newAssemblyName();myAssemblyName.Name=
“MyAssembly”;AssemblyBuilder
myAssemblyBuilder=
AppDomain.CurrentDomain.DefineDynamicAssembly
(myAssemblyName,



AssemblyBulderAccess.Save);myAssemblyBuilder.Save(“MyAssembly.dll”);
C.AssemblyNamemyAssemblyName=



newAssemblyName();AssemblyBuildermyAssemblyBuilder=
AppDomain.CurrentDomain.DefineDynamicAssembly
(myAssemblyName,
AssemblyBuilderAccess.RunAndSave);myAssemblyBuilder.Save(“MyAssemb
ly.dll”);
D.AssemblyNamemyAssemblyName=
newAssemblyName(“MyAssembly”);AssemblyBuildermyAssemblyBuilder=
AppDomain.CurrentDomain.DefineDynamicAssembly
(myAssemblyName,
AssemblyBuilderAccess.Save);myAssemblyBuilder.Save(“c:\\MyAssembly.dll”
);
答案: B
第24题
你需要从你的托管代码使用平台调用服务（platform invokeservices）调用一
个非托管的函数，你应该怎么做？
A.CreateaclasstoholdDLLfunctionsandthencreateprototypemethodsby
usingmanaged
Code。
B.注册你的程序集为COM组件然后从COM中引用你的托管代码。
C.为你的托管代码导出类型库。
D.导入类型库作为一个程序集然后创建COM对象实例。
答案: A
第25题
你使用反射（Reflection）来获得方法MyMethod的信息。你需要获取MyMethod
方法是否在派生类中可以访问，你应该如何做？
A.访问MethodInfo的IsAssembly属性。
B.访问MethodInfo的IsVirtual属性。
C.访问MethodInfo的IsStatic属性。
D.访问MethodInfo的IsFamily属性。
答案: D
第26题
请使用下面的条件确定一个类型：
1） 是一个数字。
2） 不大于65,535
请问，是哪一个类型？
A.System.UInt16



B.int
C.System.String
D.System.IntPtr
答案: A
第27题
你正在写用户验证和授权的代码。username,password,和roles存储在你的应
用数据存储区。你需要建立一个用于授权检查的用户安全上下文，例如IsInRole。
你写如下的代码段去验证用户：
if(!TestPassword(userName,password))
thrownewException(“couldnotauthenticateuser”);
String[]userRolesArray=LookupUserRoles(userName);
你需要完成这段代码从而为用户建立安全上下文。你应该使用那个代码段？
A.GenericIdentityident=newGenericIdentity(userName);
GenericPrincipalcurrentUser=newGenericPrincipal(ident,userRolesArray);
Thread.CurrentPrincipal=currentUser;
B.WindowsIdentityident=new
WindowsIdentity(userName);WindowsPrincipalcurrentUser=
newWindowsPrincipal(ident);Thread.CurrentPrincipal=currentUser;
C.NTAccountuserNTName=newNTAccount(userName);GenericIdentity
ident=new
GenericIdentity(userNTName.Value);GenericPrincipalcurrentUser=new
GenericPrincipal(ident,userRolesArray);Thread.CurrentPrincipal=
currentUser;
D.IntPtrtoken=IntPtr.Zero;token=LogonUserUsingInterop(username,
encryptedPassword);WindowsImpersonationContextctx=
WindowsIdentity.Impersonate(token);
答案: A
第28题
你正在为一个HongKong的客户开发一个应用。你需要为本地的货币显示一个符
号。你应该使用那段代码？
A.NumberFormatInfoculture=newCultureInfo(“zh-HK”).NumberFormat;
culture.NumberNegativePattern=1;returnnumberToPrint.ToString(“C”,
culture);
B.NumberFormatInfoculture=newCultureInfo(“zh-HK”).NumberFormat;
culture.CurrencyNegativePattern=1;returnnumberToPrint.ToString(“C”,
culture);
C.CultureInfoculture=newCultureInfo(“zh-HK”);return
numberToPrint.ToString(“-(0)”,culture);
D.CultureInfoculture=newCultureInfo(“zh-HK”);return
numberToPrint.ToString(“()”,culture);



答案: B



第29题
你正在开发一个将执行数学计算的应用。你需要确保应用能够同时的执行多个计
算。你应该怎么做？
A.设置ProcessThread对象的IdealProcessor属性。
B.设置ProcessThread对象的ProcessorAffinity属性。
C.使用foreach进行计算；调用ThreadPool的QueueUserWorkItem方法。
D.设置Process.GetCurrentProcess().BasePriority为High.
答案: C
第30题
你正在开发一个名为PollingService的服务，这个服务定期的调用一些需要长时
间运行的过程。这些过程被DoWork方法调用。你的服务代码如下：
refclassPollingService:publicServiceBase{
public:
staticboolblnExit=false;
protected:
overridevoidOnStart(String^args){
do{
DoWork();
}while(!blnExit);
} overridevoidOnStop(){
blnExit=true;
} private:
voidDoWork(){}};
当你试图去启动服务的时候，你收到一个错误：在本地计算机上不能启动
PollingService服务。Error1053：服务不响应启动或控制。你需要去修改服务代
码，使服务能够被正确启动。你应该如何做？
A.把循环代码从OnStart方法移动到服务类的构造函数中。
B.在服务的设计界面拖入一个timer组件。把调用长运行时间过程的代码从
OnStart方法移动到timer的Tick事件中。在OnStart方法中设置timer的Enabled
属性为True，并且调用timer的Start方法。
C.给服务类增加一个类级别的System.Timers.Timer变量。然后在timer的
Elapsed事件中调用DoWork方法。在OnStart方法中设置timer的Enabled属性为
True，并且调用timer的Start方法。
D.把循环代码从OnStart方法移动到DoWork方法中。
答案: C



第31题
你是公司A的一个开发人员。你创建了一个名为Company1的程序集。Company1
包含了一个public方法。全局程序集中包含了另一个名为Company2的程序集。
你必须保证，public方法只能够被Company2调用。你需要使用下面哪个权限类？
A.GacIdentityPermission
B.PublisherIdentityPermission
C.DataProtectionPermission
D.StrongNameIdentityPermission
答案: D
第32题
你正在创建一个将被用于多个应用的、名为Company1的强类型程序集。
Company1在整个开发周期中会经常的重新编译。你需要保证，程序集在每次重
新编译后使用它的应用都能正确的运行。为此，你将配置开发Company1的计算
机，使每个应用都能使用Company1的最新编译版本。你应该通过下面哪两个步
骤完成？（每个答案代表解决方案的一部分）
A.创建一个指向强类型程序集编译输出目录的DEVPATH 环境变量，。
B.在machine.config配置文件中增加：<developmentMode
developerInstallation="true"/>
C.在machine.config配置文件中增加：
<dependentAssembly>
<assemblyIdentityname="Company1"publicKeyToken="32ab4ba45e0a69a1"
language="en-US"version="*.*.*.*"/>
<publisherPolicyapply="no"/>
</dependentAssembly>
D.为使用强类型程序集的每个应用的配置文件增加：<supportedRuntime
version="*.*.*.*"/>
E.为使用强类型程序集的每个应用的配置文件增加：
<dependentAssembly>
<assemblyIdentityname="Company1"publicKeyToken="32ab4ba45e0a69a1"
language="en-US"version="*.*.*.*"/>
<bindingRedirectnewVersion="*.*.*.*"/>
</dependentAssembly>
答案: A, B
第33题
你正在定义一个名为CompanyClass的、包含几个子对象的类。CompanyClass
类包含一个操作子对象的方法ProcessChildren。CompanyClass对像将被序列
化。你需要确保在CompanyClass对象和所有子对象被重新构造后
ProcessChildren方法将被执行。你应该通过下面那两个操作达到这个目的？（每
个答案代表解决方案的一部分）



A.在ProcessChildren方法上应用OnDeserializing属性。
B.让CompanyClass实现IDeserializationCallback接口。
C.让CompanyClass从ObjectManager类继承。
D.在ProcessChildren方法上应用OnSerialized属性。
E.创建一个调用ProcessChildren的GetObjectData方法。
F.创建一个调用ProcessChildren的OnDeserialization方法。
答案: B, F
第34题
你正在开发一个从应用目录动态的装入程序集的应用。你需要写一段代码去动态
的装入Company1.dll程序集到当前的应用执行域中。你应该使用下面那段代
码？
A.AppDomaindomain=AppDomain.CurrentDomain;stringmyPath=
Path.Combine(domain.BaseDirectory,“Company1.dll”);
Assemblyasm=Assembly.LoadFrom(myPath);
B.AppDomaindomain=AppDomain.CurrentDomain;stringmyPath=
Path.Combine(domain.BaseDirectory,
“Company1.dll”);Assemblyasm=Assembly.Load(myPath);
C.AppDomaindomain=AppDomain.CurrentDomain;stringmyPath=
Path.Combine(domain.DynamicDirectory,“Company1.dll”);Assemblyasm=
AppDomain.CurrentDomain.Load(myPath);
D.AppDomaindomain=AppDomain.CurrentDomain;Assemblyasm=
domain.GetData(“Company1.dll”);
答案: A
第35题
你需要创建一个清除队列（Queue）q的方法。你应该使用下面那段代码？
A.foreach(objecteinq){q.Dequeue();}
B.foreach(objecteinq){Enqueue(null);}
C.q.Clear();
D.q.Dequeue();
答案: C
第36题
你开发了一个需要部署的服务应用。你的网络管理员为你的服务应用创建一个用
户账号。你需要配置你的服务，让它运行在指定用户账号的上下文中。你应该如
何做？
A.创建服务安装类，设置ServiceInstaller类的StartType属性。



B.创建服务安装类，设置ServiceProcessInstaller的Account,Username,和
Password属性。
C.使用net.exe命令行工具的CONFIG 选项去安装服务。
D.使用installutil.exe命令行工具安装服务。
答案: B
第37题
你正在创建一个使用非托管资源的类。这个类引用了使用托管资源的对象。你需
要确保使用这个类的用户在不需要类实例的时候能够够释放资源。你应该做那三
个工作？
（每个答案是解决方案的一部分）
A.定义一个从WeakReference继承的类。
B.定义一个实现IDisposable接口的类。
C.创建一个类析构函数，调用其它对象的方法去释放托管资源。
D.创建一个类析构函数，释放非托管资源
E.创建一个Dispose方法，调用System.GC.Collect强制垃圾回收。
F.创建一个Dispose方法，释放非托管资源并且调用其它对象的方法释放托管资
源。
答案: B, D, F
第38题
你使用反射（Reflection）来获得方法MyMethod的信息。你需要获取MyMethod
方法是否在派生类中可以访问，你应该如何做？
A.访问MethodInfo的IsAssembly属性。
B.访问MethodInfo的IsVirtual属性。
C.访问MethodInfo的IsStatic属性。
D.访问MethodInfo的IsFamily属性。
答案: D
第39题
你正在创建一个执行复杂财务运算的类。这个类包含一个方法GetCurrentRate，
它得到当前的汇率并保存在变量currRate中。你为此类实现了序列化。为此，你
需要写一段代码，当类被反序列化后，能够使用当前的实际汇率更新currRate变
量。你应该使用下面那段代码？
A.[OnSerializing]internalvoidUpdateValue(StreamingContextcontext){
currRate=GetCurrentRate();}
B.[OnSerializing]internalvoidUpdateValue(SerializationInfoinfo)
{info.AddValue(“currentRate”,GetCurrentRate());}
C.[OnDeserializing]internalvoidUpdateValue(SerializationInfoinfo){
info.AddValue(“currentRate”,GetCurrentRate());}
D.[OnDeserialized]internalvoidUpdateValue(StreamingContextcontext){



currRate=GetCurrentRate();}
答案: D
第40题
你正在写一个使用独立存储区（isolatedstorage）存储用户参数信息的应用。应
用使用了多个程序集，而且多个用户将会在同一个机器上使用此应用。你需要在
当前的MicrosoftWindows标识和程序集的独立存储区内创建一个目录
Preferences。你应该使用下面那段代码？
A.IsolatedStorageFilestore;store=
IsolatedStorageFile.GetUserStoreForAssembly();store.CreateDirectory(“Prefe
rences”);
B.IsolatedStorageFilestore;store=
IsolatedStorageFile.GetMachineStoreForAssembly();store.CreateDirectory(“P
references”);
C.IsolatedStorageFilestore;store=
IsolatedStorageFile.GetUserStoreForDomain();store.CreateDirectory(“Prefere
nces”);
D.IsolatedStorageFilestore;store=
IsolatedStorageFile.GetMachineStoreForApplication();store.CreateDirectory(“
Preferences”);
答案: A
第41题
你的公司正在使用一个名为Application1的、基于.NETFrameworkversion1.0
的应用。这个应用当前运行在一个安装有.NETFrameworkversions1.0和1.1
的共享计算机上。现在，你需要移动这个应用到一个新的安装有.NETFramework
versions1.1和2.0计算机上。已知，这个应用被用.NETFramework1.1进行了
重新编译，但是没有用.NETFramework2.0进行编译。你需要保证应用能够运
行在新计算机的.NETFrameworkversion1.1上。你应该如何做？
A.在应用配置文件增加如下XML元素：
<configuration>
<startup>
<supportedRuntimeversion="1.1.4322"/>
<startup>
</configuration>
B.在应用配置文件增加如下XML元素：
<configuration>
<runtime>
<assemblyBinding
xmlns="urn:schemas-microsoft-com:asm.v1">
<dependentAssembly>
<assemblyIdentityname="Application1"
publicKeyToken="32ab4ba45e0a69a1"
culture="neutral"/>



<bindingRedirectoldVersion="1.0.3075.0"
newVersion="1.1.4322.0"/></dependentAssembly>
</assemblyBinding>
</runtime>
</configuration>
C.在应用配置文件增加如下XML元素：
<configuration>
<startup>
<requiredRuntimeversion="1.1.4322"/>
<startup>
</configuration>
D.在应用配置文件增加如下XML元素：
<configuration>
<runtime>
<assemblyBinding
xmlns="urn:schemas-microsoft-com:asm.v1">
<dependentAssembly>
<assemblyIdentityname="Application1"
publicKeyToken="32ab4ba45e0a69a1"
culture="neutral"/>
<bindingRedirectoldVersion="1.0.3075.0"
newVersion="1.1.4322.0"/>
</dependentAssembly>
</assemblyBinding>
</runtime>
</configuration>
答案: A
第42题
你正在为应用装载一个新的程序集。你需要为程序集重载缺省的证据集
（Evidence）。如果程序集是从本地的intranetzone被装载，你需要公共语言
运行库（CLR）为程序集许可一个权限集。为此，你需要建立一个证据集。你应
该使用下面哪一个代码段？
A.Evidenceevidence=newEvidence(
Assembly.GetExecutingAssembly().Evidence
);
B.Evidenceevidence=newEvidence();evidence.AddAssembly(new
Zone(SecurityZone.Intranet));
C.Evidenceevidence=newEvidence();evidence.AddHost(new
Zone(SecurityZone.Intranet));
D.Evidenceevidence=newEvidence(
AppDomain.CurrentDomain.Evidence
);



答案: C
第43题
你正在开发一个类库。此类库将打开和网络上其他计算机的网络套接字连接
（networksocketconnections）。你将部署类库到全局程序集并且许可为完全
信任。你写了如下代码去保证socket连接是可用的：
SocketPermissionpermission=new
SocketPermission(PermissionState.Unrestricted);
permission.Assert();
使用这个类库的一些应用并不需要必需的权限去打开网络套接字连接。你需要取
消断言（assertion）。你应该使用下面那个代码段：
A.CodeAccessPermission.RevertAssert();
B.CodeAccessPermission.RevertDeny();
C.permission.Deny();
D.permission.PermitOnly();
答案: A
第44题
你开发了一个名为FileService的服务。你部署这个服务到你网络上的多个服务器
上。你实现了如下代码段：
01publicvoidStartService(stringserverName){
02ServiceControllercrtl=new
03ServiceController(“FileService”);
04if(crtl.Status==ServiceControllerStatus.Stopped){
05}
06}
你需要开发一个服务管理程序，如果服务FileService停止了，则启动它。服务管
理程序启动FileService服务，要求以serverName作为输入参数来标识服务器。
你应该增加下面哪两行代码到上面的代码段？
A.在03和04行之间插入代码段：crtl.ServiceName=serverName;
B.在03和04行之间插入代码段：crtl.MachineName=serverName;
C.在03和04行之间插入代码段：crtl.Site.Name=serverName;
D.在04和05行之间插入代码段：crtl.Continue();
E.在04和05行之间插入代码段：crtl.Start();
F.在04和05行之间插入代码段：crtl.ExecuteCommand(0);
答案: B,E



第45题
你创建了一个使用最终用户身份进行运行的方法。你需要使用Microsoft
Windows用户组去验证用户。你必须增加一个代码段去验证用户是否在本地用户
组Clerk里面。你应该使用下面那个代码段？
A.WindowsIdentitycurrentUser=WindowsIdentity.GetCurrent();foreach
(IdentityReferencegrpincurrentUser.Groups){
NTAccountgrpAccount=
((NTAccount)grp.Translate(typeof(NTAccount)));
isAuthorized=grpAccount.Value.Equals(Environment.MachineName+
@”\Clerk”);
if(isAuthorized)break;}
B.WindowsPrincipalcurrentUser=
(WindowsPrincipal)Thread.CurrentPrincipal;isAuthorized=
currentUser.IsInRole(“Clerk”);
C.GenericPrincipalcurrentUser=
(GenericPrincipal)Thread.CurrentPrincipal;isAuthorized=
currentUser.IsInRole(“Clerk”):
D.WindowsPrincipalcurrentUser=
(WindowsPrincipal)Thread.CurrentPrincipal;isAuthorized=
currentUser.IsInRole(Environment.MachineName);
答案: B
第46题
你创建了一个发送e-mail的应用。一个名称为smtp.Company.com的SMTP服务
器在本地子网是可用的。为了测试应用，你使用源地址为me@Company.com，
目标地址为you@Company.com。你应该使用下面那个代码段去发送e-mail？
A.DimMailFromAsNewMailAddress("me@Company.com","Me")
DimMailToAsNewMailAddress("you@Company.com","You")
DimMessageAsNewMailMessage(MailFrom,MailTo)Message.Subject=
"Greetings"Message.Body="Test"Message.Dispose()
B.DimSMTPClientAsString="smtp.Company.com"
DimMailFromAsString=me@Company.com
DimMailToAsString=you@Company.com
DimSubjectAsString="Greetings"
DimBodyAsString="Test"DimMessageAsNewMailMessage(MailFrom,
MailTo,
Subject,SMTPClient)
C.DimMailFromAsNewMailAddress("me@Company.com","Me")
DimMailToAsNewMailAddress("you@Company.com","You")
DimMessageAsNewMailMessage(MailFrom,MailTo)Message.Subject=
"Greetings"Message.Body="Test"
DimobjClientAsNew
SmtpClient("smtp.Company.com")objClient.Send(Message)



D.DimMailFromAsNewMailAddress("me@Company.com","Me")



DimMailToAsNewMailAddress("you@Company.com","You")
DimMessageAsNewMailMessage(MailFrom,MailTo)Message.Subject=
"Greetings"Message.Body="Test"
DimInfoAsNewSocketInformationDimClientAsNewSocket(Info)
DimEncAsNewASCIIEncodingDimBytes()AsByte=
Enc.GetBytes(Message.ToString)Client.Send(Bytes)
答案: C
第47题
你需要写一个代码段，从一个流变量stream1截取开始的80个字节到一个新的字
节数组byteArray中。你同时也需要保证代码段把截取的字节数保存到一个整型
变量bytesTransferred中，你应该使用下面那个代码段？
A.bytesTransferred=stream1.Read(byteArray,0,80);
B.for(inti=0;i<80;i++){
stream1.WriteByte(byteArray[i]);
bytesTransferred=i;
if(!stream1.CanWrite){
break;
}}
C.while(bytesTransferred<80){
stream1.Seek(1,SeekOrigin.Current);
byteArray[bytesTransferred++]=
Convert.ToByte(stream1.ReadByte());}
D.stream1.Write(byteArray,0,80);bytesTransferred=byteArray.Length;
答案: A
第48题
你正在创建一个存储不同地域的客户信息的应用。你为这个应用开发了一个内部
的测试版本。你需要收集加拿大客户的区域信息，你应该使用那个代码段？
A.foreach(CultureInfoculturein
CultureInfo.GetCultures(CultureTypes.SpecificCultures))
{//Outputtheregioninformation...}
B.CultureInfocultureInfo=newCultureInfo(“CA”);//Outputtheregion
information…
C.RegionInforegionInfo=newRegionInfo(“CA”);//Outputtheregion
information…
D.RegionInforegionInfo=newRegionInfo(“”);if(regionInfo.Name==“CA”){
//Outputtheregioninformation...}
答案: C



第49题
你正在开发一个在网络上传输铭感信息的服务器应用。你创建了一个
X509Certificate对象certificate和一个TcpClient对象client。你需要创建一个
SslStream对象，从而通过TransportLayerSecurity1.0协议（TLS1.0安全协
议）进行通讯。你应该使用那个代码段？
A.SslStreamssl=new
SslStream(client.GetStream());ssl.AuthenticateAsServer(certificate,
false,SslProtocols.None,true);
B.SslStreamssl=new
SslStream(client.GetStream());ssl.AuthenticateAsServer(certificate,
false,SslProtocols.Ssl3,true);
C.SslStreamssl=new
SslStream(client.GetStream());ssl.AuthenticateAsServer(certificate,
false,SslProtocols.Ssl2,true);
D.SslStreamssl=newSslStream(client.GetStream());
ssl.AuthenticateAsServer(certificate,
false,SslProtocols.Tls,true);
答案: D
第50题
你正在开发一个使用DES（DataEncryptionStandard）算法加密铭感数据的方
法。你的方法接收如下参数：将被加密的字节数组message，密钥key，始化向
量iv。
你需要去加密数据，你也需要把加密数据写入MemoryStream 对象。你应该使
用那段代码？
A.DESdes=newDESCryptoServiceProvider();
des.BlockSize=message.Length;ICryptoTransformcrypto=
des.CreateEncryptor(key,iv);
MemoryStreamcipherStream=newMemoryStream();
CryptoStreamcryptoStream=newCryptoStream(cipherStream,
crypto,CryptoStreamMode.Write);
cryptoStream.Write(message,0,message.Length);
B.DESdes=newDESCryptoServiceProvider();
ICryptoTransformcrypto=des.CreateDecryptor(key,iv);
MemoryStreamcipherStream=newMemoryStream();CryptoStream
cryptoStream=
newCryptoStream(cipherStream,
crypto,CryptoStreamMode.Write);
cryptoStream.Write(message,0,message.Length);
C.DESdes=newDESCryptoServiceProvider();ICryptoTransformcrypto=
des.CreateEncryptor();
MemoryStreamcipherStream=newMemoryStream();CryptoStream
cryptoStream=



newCryptoStream(cipherStream,
crypto,CryptoStreamMode.Write);
cryptoStream.Write(message,0,message.Length);
D.DESdes=newDESCryptoServiceProvider();ICryptoTransformcrypto=
des.CreateEncryptor(key,iv);
MemoryStreamcipherStream=newMemoryStream();CryptoStream
cryptoStream=
newCryptoStream(cipherStream,



crypto,CryptoStreamMode.Write);cryptoStream.Write(message,0,
message.Length);
答案: D
第51题
你正在为应用域创建一个新的安全策略。你写了如下代码：
PolicyLevelpolicy=PolicyLevel.CreateAppDomainLevel();
PolicyStatementnoTrustStatement=newPolicyStatement(
policy.GetNamedPermissionSet(“Nothing”));
PolicyStatementfullTrustStatement=newPolicyStatement(
policy.GetNamedPermissionSet(“FullTrust”));
你需要为策略安排代码组，以至装载程序集默认为Nothing权限集。如果程序集
从trustedzone装载，则安全策略必须许可程序集为完全信任。（FullTrust
permissionset）。你应该使用那个代码段？
A.CodeGroupgroup1=newFirstMatchCodeGroup(
newZoneMembershipCondition(SecurityZone.Trusted),
fullTrustStatement);CodeGroupgroup2=newUnionCodegroup(
newAllMembershipCondition(),
noTrustStatement);group1.AddChild(group2);
B.CodeGroupgroup1=newFirstMatchCodeGroup(
newAllMembershipCondition(),
noTrustStatement);CodeGroupgroup2=newUnionCodeGroup(
newZoneMembershipCondition(SecurityZone.Trusted),
fullTrustStatement);group1.AddChild(group2);
C.CodeGroupgroup=newUnionCodeGroup(
newZoneMembershipCondition(SecurityZone.Trusted),
fullTrustStatement);
D.CodeGroupgroup=newFirstMatchCodeGroup(
newAllMembershipCondition(),noTrustStatement);
答案: B
第52题
你正在开发一个名为PollingService的服务，这个服务定期的调用一些需要长时
间运行的过程。这些过程被DoWork方法调用。你的服务代码如下：
ServiceBase{
boolblnExit=false;publicPollingService(){}
protectedoverridevoidOnStart(string[]args){
do{
DoWork();
}while(!blnExit);



} protectedoverridevoidOnStop(){
blnExit=true;
} privatevoidDoWork(){
...
}}
当你试图去启动服务的时候，你收到一个错误：在本地计算机上不能启动
PollingService服务。Error1053：服务不响应启动或控制。你需要去修改服务代
码，使服务能够被正确启动。你应该如何做？
A.把循环代码从OnStart方法移动到服务类的构造函数中。
B.在服务的设计界面拖入一个timer组件。把调用长运行时间过程的代码从
OnStart方法移动到timer的Tick事件中。在OnStart方法中设置timer的Enabled
属性为True，并且调用timer的Start方法。
C.给服务类增加一个类级别的System.Timers.Timer变量。然后在timer的
Elapsed事件中调用DoWork方法。在OnStart方法中设置timer的Enabled属性为
True，并且调用timer的Start方法。
D.把循环代码从OnStart方法移动到DoWork方法中。
答案: C
第53题
你需要写一个代码段，它使用名为netStream的NetworkStream对象传输字节数
组dataToSend的内容。你需要使用一个8192字节的缓冲区。你应该使用下面那
个代码段？
A.MemoryStreammemStream=new
MemoryStream(8192);memStream.Write(dataToSend,0,(int)
netStream.Length);
B.MemoryStreammemStream=new
MemoryStream(8192);netStream.Write(dataToSend,0,(int)
memStream.Length);
C.BufferedStreambufStream=newBufferedStream(netStream,8192);
bufStream.Write(dataToSend,0,dataToSend.Length);
D.BufferedStreambufStream=newBufferedStream(netStream);
bufStream.Write(dataToSend,0,8192);
答案: C
第54题
你需要开发一个显示任务进度的闪屏。如下图：
为此，你需要在屏幕上画出一个使用渐变阴影进行填充的矩形。你应该使用下面



那个代码



段？
A.Rectanglerectangle=newRectangle(10,10,450,25);
LinearGradientBrush
rectangleBrush=
newLinearGradientBrush(rectangle,Color.AliceBlue,
Color.CornflowerBlue,
LinearGradientMode.ForwardDiagonal);PenrectanglePen=new
Pen(rectangleBrush);
Graphicsg=this.CreateGraphics();g.DrawRectangle(rectanglePen,
rectangle);
B.Rectanglerectangle=newRectangle(10,10,450,25);
LinearGradientBrush
rectangleBrush=
newLinearGradientBrush(rectangle,Color.AliceBlue,
Color.CornflowerBlue,
LinearGradientMode.ForwardDiagonal);PenrectanglePen=new
Pen(rectangleBrush);
Graphicsg=this.CreateGraphics();g.FillRectangle(rectangleBrush,
rectangle);
C.RectangleFrectangle=newRectangleF(10f,10f,450f,25f);Point[]points=
new
Point[]{newPoint(0,0),
newPoint(110,145)};LinearGradientBrushrectangelBrush=
newLinearGradientBrush(rectangle,Color.AliceBlue,
Color.CornflowerBlue,
LinearGradientMode.ForwardDiagonal);PenrectanglePen=new
Pen(rectangleBrush);Graphicsg=this.CreateGraphics();
g.DrawPolygon(rectanglePen,points);
D.RectangleFrectangle=newRectangleF(10f,10f,450f,25f);SolidBrush
rectangleBrush=
newSolidBrush(Color.AliceBlue);PenrectanglePen=new
Pen(rectangleBrush);
Graphicsg=this.CreateGraphics();g.DrawRectangle(rectangleBrush,
rectangle);
答案: B
第55题
你正在开发一个在字符串中查找子串的方法。这个方法将被本地化为意大利区
域。你的方法接收如下参数：被查询的字符串searchList，要查找的字符串
searchValue。你应该使用下面那个代码段？
AreturnsearchList.IndexOf(searchValue);
B.CompareInfocomparer=
newCultureInfo(“it-IT”).CompareInfo;returncomparer.Compare(searchList,
searchValue);



C.CultureInfoComparer=new
CultureInfo(“it-IT”);if(searchList.IndexOf(searchValue)
>0){
returntrue;}else{
returnfalse;}
D.CompareInfocomparer=
newCultureInfo(“it-IT”).CompareInfo;if(comparer.IndexOf(searchList,
searchValue)>0){
returntrue;}else{
returnfalse;}



答案: D
第56题
你正在为一个客户开发一个财务报表。你的客户在美国有总部，在密西哥有分部。
你需要保证客户在密西哥产生的报表，则当前的日期格式为MexicanSpanish格
式。你应该使用下面那个代码段实现？
A.DateTimeFormatInfodtfi=newCultureInfo(“es-MX”,
false).DateTimeFormat;
DateTimedt=newDateTime(DateTime.Today.Year,DateTime.Today.Month,
DateTime.Today.Day);stringdateString=dt.ToString(dtfi.LongDatePattern);
B.Calendarcal=newCultureInfo(“es-MX”,false).Calendar;DateTimedt=
new
DateTime(DateTime.Today.Year,DateTime.Today.Month,
DateTime.Today.Day);StrongDateString=dt.ToString();
C.stringdateString=DateTimeFormatInfo.CurrentInfo
GetMonthName(DateTime.Today.Month);
D.stringdateString=DateTime.Today.Month.ToString(“es-MX”);
答案: A
第57题
你正在创建一个应用，它从应用配置文件的自定义节中读取值。XML自定义节如
下：
<ProjectSectionname="ProjectCompany">
<rolename="administrator"/>
<rolename="manager"/>
<rolename="support"/>
</ProjectSection>
你需要写一个代码段去定义一个名为Role的类。而且你需要保证Role类使用从
配置文件自定义节读取的数据进行初始化。你应该使用下面那个代码段？
A.publicclassRole:ConfigurationElement
{ internalstring_ElementName=“name”;
[ConfigurationProperty("role")]
publicstringName
{ get
{ return((string)base[“role”]);
}}} B.publicclassRole:ConfigurationElement{



internalstring_ElementName=“role”;



[ConfigurationProperty("name",RequiredValue=true)]
publicstringName{
get{
return((string)base[“name”]);
}}} C.publicclassRole:ConfigurationElement{
internalstring_ElementName=“role”;
privateString_name;
[ConfigurationProperty("name")]
publicstringName{
get{
return_name;
}}} D.publicclassRole:ConfigurationElement{
internalstring_ElementName=“name”;
privateString_name;
[ConfigurationProperty("role",RequiredValue=true)]
publicstringName{
get{
return_name;
}}}
答案: B
第58题
你需要从你的托管代码使用平台调用服务（platform invokeservices）调用一
个非托管的函数，你应该怎么做？
A.CreateaclasstoholdDLLfunctionsandthencreateprototypemethodsby
usingmanaged
Code。
B.注册你的程序集为COM组件然后从COM中引用你的托管代码。
C.为你的托管代码导出类型库。
D.导入类型库作为一个程序集然后创建COM对象实例。
答案: A



第59题
你正在使用MicrosoftVisualStudio2005IDE去检查一个返回字符串的方法。你
指定方法的返回值保存到字符串变量fName中。你需要写一个代码段，如果
fName的值不等于"Company"则打印如下的单行文本消息“TestFailed:”fName。
你也同时需要保证，你的代码段并不影响或打断应用的执行。你应该使用下面那
个代码段？
A.Debug.Assert(fName==“Company”,“TestFailed:”,fName);
B.Debug.WriteLineIf(fName!=“Company”,fName,“TestFailed”);
C.if(fName!="Company"){
Debug.Print(“TestFailed:”);
Debug.Print(fName);
} D.if(fName!="Company"){
Debug.WriteLine(“TestFailed:”);
Debug.WriteLine(fName);
}
答案: B
第60题
你正在开发一个使用自定义身份验证和基于角色安全的应用。你需要写一段代码
在运行时为每一个线程指定一个未经过身份验证的标识对象。你可以使用下面那
个代码段？
A.AppDomaindomain=
AppDomain.CurrentDomain;domain.SetPrincipalPolicy(PrincipalPolicy.Windo
wsPrincipal);
B.AppDomaindomain=
AppDomain.CurrentDomain;domain.SetThreadPrincipal(new
WindowsPrincipal(null));
C.AppDomaindomain=AppDomain.CurrentDomain;
domain.SetAppDomainPolicy(
PolicyLevel.CreateAppDomainLevel());
D.AppDomaindomain=
AppDomain.CurrentDomain;domain.SetPrincipalPolicy(
PrincipalPolicy.UnauthenticatedPrincipal);
答案: D
第61题
你写了一个包含如下代码的类Employee：
publicclassEmployee
{ stringemployeeId,employeeName,jobTitleName;
publicstringGetName(){returnemployeeName;}



publicstringGetTitle(){returnjobTitleName;}
}
你需要在类型库中把这个类公开为COM。而且COM接口能够向前兼容
Employee类的新版本。你需要选择一种方法去生成COM接口，你应该怎么做？
A.增加如下的属性定义：
[ClassInterface(ClassInterfaceType.None)]publicclassEmployee{
B.增加如下的属性定义：
[ClassInterface(ClassInterfaceType.AutoDual)]publicclassEmployee{
C.[ComVisible(true)]publicclassEmployee{
D.为类定义一个接口并增加如下的属性定义
[ClassInterface(ClassInterfaceType.None)]publicclassEmployee:IEmployee{
答案: D
第62题
你正在写一个接收DateTime参数、返回一个Boolean值的多路委托，你应该使
用下面那个代码段？
A.publicdelegateintPowerDeviceOn(bool,DateTime);
B.publicdelegateboolPowerDeviceOn(Object,EventArgs);
C.publicdelegatevoidPowerDeviceOn(DateTime);
D.publicdelegateboolPowerDeviceOn(DateTime);
答案: A
第63题
你正在创建一个存储数据修改的撤销缓冲区（undobuffer）。你需要保证撤销功
能首先撤销最近的数据修改，而且撤销缓冲区只允许存储字符串。你应该使用下
面那段代码实现？
A.Stack<string>undoBuffer=newStack<string>();
B.StackundoBuffer=newStack();
C.Queue<string>undoBuffer=newQueue<string>();
D.QueueundoBuffer=newQueue();
答案: A
第64题
你创建了一个Vehicle类的定义如下：
publicclassVehicle
{



[XmlAttribute(AttributeName="category")]
publicstringvehicleType;
publicstringmodel;
[XmlIgnore]
publicintyear;
[XmlElement(ElementName="mileage")]
publicintmiles;
publicConditionTypecondition;
publicVehicle(){
} publicenumConditionType{
[XmlEnum("Poor")]BelowAverage,
[XmlEnum("Good")]Average,
[XmlEnum("Excellent")]AboveAverage
}}
你创建了类Vehicle的一个实例。你为Vehicle类实例的public字段指定了如下
的值：
vehicleType：car；mode：lracer；year：2002；miles：15000；condition：
AboveAverage
你需要识别出下面那个XML段是Vehicle类实例被序列化后的输出？
A.<?xmlversion="1.0"encoding="utf-8"?>
<Vehicle
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:xsd="http://www.w3.org/2001/XMLSchema""
vehicleType="car">
<model>racer</model>
<miles>15000</miles>
<condition>AboveAverage</condition>
</Vehicle>
B.<?xmlversion="1.0"encoding="utf-8"?>
<Vehiclexmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:xsd="http://www.w3.org/2001/XMLSchema"
category="car">
<model>racer</model>
<mileage>15000</mileage>
<condition>Excellent</condition>
</Vehicle>
C.<?xmlversion="1.0"encoding="utf-8"?>
<Vehicle
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:xsd="http://www.w3.org/2001/XMLSchema"
category="car">
<model>racer</model>



<mileage>15000</mileage>
<conditionType>Excellent</conditionType>



</Vehicle>
D.<?xmlversion="1.0"encoding="utf-8"?>
<Vehicle
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<category>car</category>
<model>racer</model>
<mileage>15000</mileage>
<condition>Excellent</condition>
</Vehicle>
答案: B
第65题
你正在测试一个组件，它把Meeting类实例序列化后保存到文件系统中。其中
Meeting类定义如下：
publicclassMeeting
{ privatestringtitle;
publicintroomNumber;
publicstring[]invitees;
publicMeeting(){}
publicMeeting(stringt){title=t;}
}
组件中的一个过程包含如下代码：
MeetingmyMeeting=newMeeting(“Goals”);
myMeeting.roomNumber=1100;
string[]attendees=newstring[2]{“Company”,“Mary”};
myMeeting.invitees=attendees;
XmlSerializerxs=newXmlSerializer(typeof(Meeting));
StreamWriterwriter=newStreamWriter(@"C:\Meeting.xml");
Xs.Serialize(writer,myMeeting);
writer.Close();
你需要识别出下面那个XML块是C:\Meeting.xml文件的内容？
A.<?xmlversion="1.0"encoding="utf-8"?>
<Meetingxmlns:xsd="http://www.w3.org/2001/XMLSchema"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<title>Goals</title>
<roomNumber>1100</roomNumber>
<invitee>Company</invitee>
<invitee>Mary</invitee>
</Meeting>
B.<?xmlversion="1.0"encoding="utf-8"?>



<Meetingxmlns:xsd="http://www.w3.org/2001/XMLSchema"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<roomNumber>1100</roomNumber>
<invitees>
<string>Company</string>
<string>Mary</string>
</invitees>
</Meeting>
C.<?xmlversion="1.0"encoding="utf-8"?>
<Meetingxmlns:xsd="http://www.w3.org/2001/XMLSchema"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
title="Goals">
<roomNumber>1100</roomNumber>
<invitees>
<string>Company</string>
<string>Mary</string>
</invitees>
</Meeting>
D.<?xmlversion="1.0"encoding="utf-8"?>
<Meetingxmlns:xsd="http://www.w3.org/2001/XMLSchema"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<roomNumber>1100</roomNumber>
<invitees>
<string>Company</string>
</invitees>
<invitees>
<string>Mary</string>
</invitees>
</Meeting>
答案: B
第66题
你正在改变文件MyData.xml的安全设置。你需要保留已经继承的访问规则，但
是不会通过继承被父对象修改。你应该怎么做？
A.FileSecuritysecurity=newFileSecurity("mydata.xml",
AccessControlSections.All);security.SetAccessRuleProtection(true,
true);File.SetAccessControl(“mydata.xml”,security);
B.FileSecuritysecurity=new
FileSecurity();security.SetAccessRuleProtection(true,
true);File.SetAccessControl(“mydata.xml”,security);
C.FileSecuritysecurity=
File.GetAccessControl(“mydata.xml”);security.SetAccessRuleProtection(true,
true);
D.FileSecuritysecurity=



File.GetAccessControl(“mydata.xml”);security.SetAuditRuleProtection(true,
true);File.SetAccessControl(“mydata.xml”,security);
答案: A
第67题
你正在创建一个类，它用于去比较指定格式的字符串。为此，你需要实现
IComparable<string>接口。你应该使用下面那个代码段？
A.publicclassPerson:IComparable<string>{
publicintCompareTo(stringother){
}}
B.publicclassPerson:IComparable<string>{
publicintCompareTo(objectother){
}}
C.publicclassPerson:IComparable<string>{
publicboolCompareTo(stringother){
}}
D.publicclassPerson:IComparable<string>{
publicboolCompareTo(objectother){
}}
答案: A
第68题
你正在开发一个去解密数据的方法。已知数据是使用TripleDES算法进行加密
的。你的方法接收如下参数：将被解密的字节数组cipherMessage，密钥key，
始化向量iv。
你需要使用TripleDES类去解密数据，并且把结果放入一个字符串中。你应该使
用那段代码？
A.TripleDESdes=newTripleDESCryptoServiceProvider();des.BlockSize=
cipherMessage.Length;ICryptoTransformcrypto=des.CreateDecryptor(key,
iv);MemoryStreamcipherStream=new
MemoryStream(cipherMessage);CryptoStream
cryptoStream=
newCryptoStream(
cipherStream,crypto,CryptoStreamMode.Read);stringmessage;message=
new
StreamReader(cryptoStream).ReadToEnd();
B.TripleDESdes=newTripleDESCryptoServiceProvider();des.FeedbackSize
= cipherMessage.Length;ICryptoTransformcrypto=des.CreateDecryptor(key,
iv);MemoryStreamcipherStream=new
MemoryStream(cipherMessage);CryptoStream
cryptoStream=
newCryptoStream(
cipherStream,crypto,CryptoStreamMode.Read);stringmessage;message=



new
StreamReader(cryptoStream).ReadToEnd();



C.TripleDESdes=newTripleDESCryptoServiceProvider();ICryptoTransform
crypto=
des.CreateDecryptor();MemoryStreamcipherStream=new
MemoryStream(cipherMessage);CryptoStreamcryptoStream=
newCryptoStream(
cipherStream,crypto,CryptoStreamMode.Read);stringmessage;message=
new
StreamReader(cryptoStream).ReadToEnd();
D.TripleDESdes=newTripleDESCryptoServiceProvider();ICryptoTransform
crypto=
des.CreateDecryptor(key,iv);MemoryStreamcipherStream=new
MemoryStream(cipherMessage);CryptoStreamcryptoStream=
newCryptoStream(
cipherStream,crypto,CryptoStreamMode.Read);stringmessage;message=
new
StreamReader(cryptoStream).ReadToEnd();
答案: D
第69题
你需要写一段代码去创建一个新的应用程序域。你应该使用下面哪段代码？
A.AppDomainSetupmySetup=
AppDomain.CurrentDomain.SetupInformation;mySetup.ShadowCopyFiles=
“true”;
B.System.Diagnostics.ProcessmyProcess;myProcess=new
System.Diagnostics.Process();
C.AppDomaindomain;domain=
AppDomain.CreateDomain(“CompanyDomain”):
D.System.ComponentModel.ComponentmyComponent;myComponent=
new
System.ComponentModel.Component();
答案: C
第70题
你正在测试一个执行进程检查的方法。这个方法返回一个包含被进程装载的所有
模块的名称和完整路径的ArrayList。现在，你需要列出被进程
C:\TestApps\Process1.exe装载的所有模块，你应该使用下面哪段代码？
A.ArrayListar=newArrayList();Process[]procs;ProcessModuleCollection
modules;procs=
Process.GetProcesses(@”Process1”);if(procs.Length>0){modules=
porcs[0].Modules;
foreach(ProcessModulemodinmodules){
ar.Add(mod.ModuleName);
}}
B.ArrayListar=newArrayList();Process[]procs;ProcessModuleCollection



modules;procs=
Process.GetProcesses(@”C:\TestApps\Process1.exe”);if(procs.Length>0)
{modules=
porcs[0].Modules;
foreach(ProcessModulemodinmodules){
ar.Add(mod.ModuleName);
}}
C.ArrayListar=newArrayList();Process[]procs;ProcessModuleCollection
modules;procs=



Process.GetProcessesByName(@”Process1”);if(procs.Length>0){modules
= porcs[0].Modules;
foreach(ProcessModulemodinmodules){
ar.Add(mod.FileName);
}}
D.ArrayListar=newArrayList();Process[]procs;ProcessModuleCollection
modules;procs=
Process.GetProcessesByName(@”C:\TestApps\Process1.exe”);if
(procs.Length>0){
modules=porcs[0].Modules;
foreach(ProcessModulemodinmodules){
ar.Add(mod.FileName);
}}
答案: C
第71题
你写了一个如下的自定义异常处理类CustomException：
PublicClassCustomExceptionInheritsApplicationException
PublicSharedCOR_E_ARGUMENTAsInt32=&H80070057
PublicSubNew(ByValstrMessageAsString)
MyBase.New(strMessage)
HResult=COR_E_ARGUMENT
EndSub
EndClass
你需要使用CustomException类实现一段能够立即让COM调用者获得控制权的
代码。同时能够保证调用者能够访问到错误代码。你应该使用下面哪段代码？
A.ReturnMarshal.GetExceptionForHR(_
CustomException.COR_E_ARGUMENT)
B.ReturnCustomException.COR_E_ARGUMENT
C.Marshal.ThrowExceptionForHR(_
CustomException.COR_E_ARGUMENT)
D.ThrowNewCustomException("Argumentisoutofbounds")
答案: D
第72题
你正在写一个返回值为ArrayList对象al的方法。你需要保证对ArrayList的修改是
线程安全的。你应该使用下面哪段代码？
A.ArrayListal=newArrayList();lock(al.SyncRoot){
returnal;}
B.ArrayListal=newArrayList();lock(al.SyncRoot.GetType()){



returnal;}
C.ArrayListal=newArrayList();Monitor.Enter(al);Monitor.Exit(al);returnal;
D.ArrayListal=newArrayList();ArrayListsync_al=
ArrayList.Synchronized(al);returnsync_al;
答案: D
第73题
你正在开发一个实现电子问卷的应用。问卷共有25个答案为true 或false的问
题。你需要完成如下任务：1）初始化每个问题答案为true；
2）每个问题答案使用最小的内存。
你应该选择使用那钟方式进行存储答案？
A.BitVector32answers=newBitVector32(1);
B.BitVector32answers=newBitVector32(-1);
C.BitArrayanswers=newBitArray(1);
D.BitArrayanswers=newBitArray(-1);
答案: B
第74题
你需要读取文件Message.txt的完整内容到一个字符串变量中。你应该使用哪段
代码？
A.stringresult=null;StreamReaderreader=new
StreamReader(“Message.txt”);result=
reader.Read().ToString();
B.stringresult=null;StreamReaderreader=new
StreamReader(“Message.txt”);result=
reader.ReadToEnd();
C.stringresult=string.Empty;StreamReaderreader=new
StreamReader(“Message.txt”);while
(!reader.EndOfStream){
result+=reader.ToString();}
D.stringresult=null;StreamReaderreader=new
StreamReader(“Message.txt”);result=
reader.ReadLine();
答案: B
第75题
你正在创建一个名为Age的类。你需要保证Age对象的集合能够被排序。你应该
使用下面哪段代码？
A.publicclassAge{
publicintValue;
publicobjectCompareTo(objectobj){
if(objisAge){
Age_age=(Age)obj;



returnValue.ComapreTo(obj);
} thrownewArgumentException(“objectnotanAge”);
}} B.publicclassAge{
publicintValue;
publicobjectCompareTo(intiValue){
try{
returnValue.ComapreTo(iValue);
}catch{
thrownewArgumentException(“objectnotanAge”);
}}} C.publicclassAge:IComparable{
publicintValue;
publicintCompareTo(objectobj){
if(objisAge){
Age_age=(Age)obj;
returnValue.ComapreTo(_age.Value);
} thrownewArgumentException(“objectnotanAge”);
}} D.publicclassAge:IComparable{
publicintValue;
publicintCompareTo(objectobj){
try{
returnValue.ComapreTo(((Age)obj).Value);
}catch{
return-1;
}}}
答案: C
第76题
你写了如下代码去实现CompanyClass.MyMethod方法：
publicclassCompanyClass{
publicintMyMethod(intarg){
returnarg;



}}
你需要在你的程序集中使用一个和CompanyClass不相关的类动态的去调用
CompanyClass.MyMethod方法。你应该使用下面哪段代码？
A.CompanyClassmyClass=newCompanyClass();
Typet=typeof(CompanyClass);
MethodInfom=t.GetMethod(“MyMethod”);
inti=(int)m.Invoke(this,newobject[]{1});
B.CompanyClassmyClass=newCompanyClass();
Typet=typeof(CompanyClass);
MethodInfom=t.GetMethod(“MyMethod”);
inti=(int)m.Invoke(myClass,newobject[]{1});
C.CompanyClassmyClass=newCompanyClass();
Typet=typeof(CompanyClass);
MethodInfom=t.GetMethod(“CompanyClass.MyMethod”);
inti=(int)m.Invoke(myClass,newobject[]{1});
D.Typet=Type.GetType(“CompanyClass”);
MethodInfom=t.GetMethod(“MyMethod”);
inti=(int)m.Invoke(this,newobject[]{1});
答案: B
第77题
你创建了一个如下的、包含类层次定义的类库：
(行号只作为引用标识，没有实际意义)
01publicclassGroup{
02publicEmployee[]Employees;
03}
04publicclassEmployee{
05publicstringName;
06}
07publicclassManager:Employee{
08publicintLevel;
09}
你创建了一个Group类的实例并且为实例的字段进行了赋值。当你使用
XmlSerializer类的Serialize方法试图去序列化实例的时候，你收到了
InvalidOperationException异常和错误消息：“在产生XML文档时有一个错误。”。
为此，你需要修改上述代码，使Group实例能够使用XmlSerializer成功的序列化。
同时你也需要保证，输出的XML包含所有类层次中的public属性。你应该如何修
改？
A.在行1和行2之间插入：
[XmlArrayItem(Type=typeof(Employee))]
[XmlArrayItem(Type=typeof(Manager))]
B.在行1和行2之间插入：
[XmlElement(Type=typeof(Employees))]

C.在行1和行2之间插入：
[XmlArray(ElementName="Employees")]
D.在行3和行4之间插入：
[XmlElement(Type=typeof(Employee))]
并且在行6和行7之间插入：
[XmlElement(Type=typeof(Manager))]
答案: A
第78题
你是公司A的一个开发人员。你创建了一个名为Company1的程序集。Company1
包含了一个public方法。全局程序集中包含了另一个名为Company2的程序集。
你必须保证，public方法只能够被Company2调用。你需要使用下面哪个权限类？
A.GacIdentityPermission
B.PublisherIdentityPermission
C.DataProtectionPermission
D.StrongNameIdentityPermission
答案: D
第79题
你正在创建一个列出远程计算机上进程信息的应用。这个应用需要一个方法执行
如下的任务：
1） 以字符串参数strComputer接收远程计算机名称。
2） 返回一个ArrayList对象，它包含运行在远程计算机上所有进程的名称。
为此，你需要写一段代码得到运行在远程计算机上所有进程的名称，并且增加名
称到ArrayList对象中。请问，你应该使用下面哪段代码？
A.ArrayListal=newArrayList();Process[]procs=
Process.GetProcessesByName(strComputer);foreach(Processprocinprocs)
{ al.Add(proc);}
B.ArrayListal=newArrayList();Process[]procs=
rocess.GetProcesses(strComputer);foreach
(Processprocinprocs){
al.Add(proc);}
C.ArrayListal=newArrayList();Process[]procs=
Process.GetProcessesByName(strComputer);foreach(Processprocinprocs)
{ al.Add(proc.ProcessName);}
D.ArrayListal=newArrayList();Process[]procs=
rocess.GetProcesses(strComputer);foreach
(Processprocinprocs){
al.Add(proc.ProcessName);}



答案: D



第80题
你正在写一个名为MyDictionary的自定义键/值对的集合（dictionary）。你需要
保证MyDictionary是类型安全的。你应该使用下面哪段代码？
A.ClassMyDictionaryImplementsDictionary(OfString,String)
B.ClassMyDictionaryInheritsHashTable
C.ClassMyDictionaryImplementsIDictionary
D.ClassMyDictionary
EndClass
DimtAsNewDictionary(OfString,String)
DimdictAsMyDictionary=CType(t,MyDictionary)
答案: A

(1)以下叙述正确的是: BC
A.接口中可以有虚方法
B.一个类可以实现多个接口。
C.接口不能被实例化。
D.接口中可以包含已实现的方法。

(2)从数据库读取记录,你可能用到的方法有:BCD
 A. ExecuteNonQuery
 B. ExecuteScalar
C Fill
 D. ExecuteReader
2.对于一个实现了IDisposable接口的类以下哪些项可以执行与释放或重置非托管资源相关的应程序定义的任务?(多选)(ABC)
A. Close B. Dispose CFinalize D.using E.Quit
3.以下关于ref和out的描述哪些项是正确的?(多
选)(ACD)
A.使用ref参数,传递到ref参数的参数必须最先初始化。
B.使用out参数,传递到out参数的参数必须最先初始化。
C.使用ref参数,必须将参数作为ref参数显式传递到方法。
D.使用out参数,必须将参数作为out参数显式传递到方法。
1.在对SQL Server数据库操作时应选用(A)
a)SQL Server NET Framework数据提供程序
b)OLE DB NET Framework数据提供程序
c)ODBC NET Framework数据提供程序
d)Oracle. NET Framework数据提供程序
2.下列选项中,(C)是引用类型。
a)enum类型b)struct类型c)string类型d)int类型
3关于ASPNET中的代码隐藏文件的描述正确的是(C)
a)Web窗体页的程序的逻辑由代码组成,这些代码的创建用于与窗体交互。编程逻辑唯一与用户界面不同的文件中。该文件称作为“代码隐藏”文件,如果用创建,该文件将具有ascx.cs”扩展名。
b)项目中所有Web窗体页的代码隐藏文件都被编译成exe文件。
c)项目中所有的Web窗体页的代码隐藏文件都被编译成项
目动态链接库文件。
d)以上都不正确。
4.以下描述错误的是(A)
a)在C++中支持抽象类而在C#中不支持抽象类。
b)C++中可在头文件中声明类的成员而在CP文件中定义类
的成员,在C#中没有头文件并且在同一处声明和定义类的
成员。
c)在C#中可使用new修饰符显式隐藏从基类继承的成员
d)在C#中要在派生类中重新定义基类的虚函数必须在前面
加 Override
5#的数据类型有(B)[原文为D,有误]
a)值类型和调用类型;b)值类型和引用类型;c)引用类型和
关系类型;d关系类型和调用类型
6.下列描述错误的是(D)
a)类不可以多重继承而接口可以
b)抽象类自身可以定义成员而接口不可以
c)抽象类和接口都不能被实例化
一个类可以有多个基类和多个基接口
7在DOM中,装载一个XML文档的方法(B)[原文为D,
有误]
a)save方法b)load方法c)loadXML方法d)send方法
8.下列关于构造函数的描述正确的是(C)
a)构造函数可以声明返回类型。
b)构造函数不可以用private修饰
c)构造函数必须与类名相同
d)构造函数不能带参数
10.int myArray3=new int[3][] {(new int[3](5,6,2},new
int[]6,9,,8,},new int[2]3,2}} myArray33[2][2]的值是(D)
a)9 b)2 c)6 d)越界
11.接口是一种引用类型,在接口中可以声明(A),但不可以声明公有的域或私有的成员变量。
a)方法、属性、索引器和事件;b)方法、属性信息、属性
c)索引器和字段:d)事件和字段
12.ASPNET框架中,服务器控件是为配合Web表单工作而
专门设计的。服务器控件有两种类型,它们是(A)
a)HTML控件和Web控件b)HTML控件和XML控件c)XML
控件和Web控件d)HTML控件和IS控件
13.ASPNET中,在Web窗体页上注册一个用户控件,指定该控件的名称为Mike,正确的注册指令为(D)
a)%@Register TagPrefix ="Mike"TagName ="Space2"Src ="myX. ascx%)
b)%@Register TagPrefix ="Space2" TagName ="Mike"Src ="myX. ascx%)
c)%@ Register TagPrefix ="SpaceXTagName ="Space2" Src="Mike"%)
d)以上皆非
14.在ADO.NET中,对于 CommandExecut对象的
方法和 ExecuteReader方法,下面叙述错误的是(C)
a)insert、 update、 delete等操作的Sq1语句主要用
 ExecuteNonQueryO方法来执行
b)ExecuteNonQuery方法返回执行Sq1语句所影响的行数。
c)SelectExecute操作的Sq1语句只能由 Reader0方法来执行
d)ExecuteReaderDataReder方法返回一个对象;
15.下列 ASPNET语句(b)正确地创建了一个与SQL Server
2000数据库的连接。
a)SqlConnection conl=new Connection( Data Source=
 localhost; Integrated Security=sspi Initial Catalog=
 myDB');
 b)SqlConnection conl new SqlConnection("Data Source
 localhost; Integrated Security =SSPI; Initial Catalog
 myDB);
 c)SqlConnection conl new SqlConnecti(Data Source
 localhost; Integrated Security =SSPI; Initial Catalog
 myDB);
 d)SqlConnection conl new OleDbConnecti(Data Source
= localhost Integrated Security=sspi Initial Catalog=
 myDB');
16.Winform中,关于 ToolBar控件的属性和事件的描述不正
确的是(D)。
a)Buttons属性表示 ToolBar控件的所有工具栏按钮
b)ButtonSize属性表示 ToolBar控件上的工具栏按钮的大小,
如高度和宽度
c)DropDownArrows属性表明工具栏按钮(该按钮有一列值
需要以下拉方式显示)旁边是否显示下箭头键
d)ButtonClick事件在用户单击工具栏任何地方时都会触发
17.在ADO.NET中执行一个存储过程时,如果要设置输出参
数则必须同时设置参数的方向和(B),必要时还要设置参
数尺寸。
a)大小
b)上限
c)初始值
d)类型:
18.如果将窗体的FormBoderStyle设置为None,则(B)。
a)窗体没有边框并不能调整大小;b)窗体没有边框但能
调整大小;
c)窗体有边框但不能调整大小;d)窗体是透明的
19如果要将窗体设置为透明的,则(B)
a)要将FormBoderStyle属性设置为None;b)要将Opacity
属性设置为小于100%得值
c)要将locked属性设置为True
d)要将 Enabled属
性设置为True
20.下列关于C#中索引器理解正确的是(BC)
a)索引器的参数必须是两个或两个以上b)索引器的参数
类型必须是整数型
c)索引器没有名字
d以上皆非
21.下面描述错误的是(CD)
a)窗体也是控件;b)窗体也是类;c)控件是从窗体继承来
的;d)窗体的父类是控件类
22.要对注册表进行操作则必须包含(D)
a)System. ComponentModel命名空间;b)System. Collections
命名空间
c)System. Threading命名空间d)Microsoft.win32命名空
间
23.要创建多文档应用程序,需要将窗体的(D)属性设为
 true
 a)DrawGrid:
 b)ShowInTaskbar:
 c)Enabled:
 d)IsMdiContainer:
24.如果设 treeViewl=new TreeViewO则
 tree View1 Nodes.add根节点)返回的是一个0类型的值。
 a)TreeNode:
 b)int:
 c)string:
)TreeView:
25.下面关于XML的描述错误的是(D)
a)XML提供一种描述结构化数据的方法
b)XML是一种简单、与平台无关并被广泛采用的标准;
c)XML文档可承载各种信息
dXML只是为了生成结构化文档
1装箱、拆箱操作发生在(C)
A.类与对象之间B对象与对象之间
C.引用类型与值类型之间D引用类型与引用类型之间
2.用户类若想支持Foreach语句需要实现的接口是:(A)
 A. IEnumerableB.IEnumerator
.ICollectionD. ICollectData
3.Net Framework通过什么与COM组件进行交互操作?
(C)
 A. Side By SideB. Web Service
 C.InteropD.PInvoke
4Net依靠以下哪一项技术解决Com存在的Del问题
的?(A)
 A. Side By SideB.Interop
 C.PInvokeD.COM+
5.装箱与拆箱操作是否是互逆的操作?(B)
A是B.否
6.以下哪个是可以变长的数组?(D)
 A. Array
 B.string]
 C.string[N]
 D. ArrayList
7用户自定义异常类需要从以下哪个类继承:(A)
 A. Exception
 B. CustomException
. ApplicationException
 D. BaseException
9.对于一个实现了IDisposable接口的类,以下哪些项可以执
行与释放或重置非托管资源相关的应用程序定义的任务?
(多选)(ABC)
 A. Close
 B.DisposeC.Finalize
 D.using
 E.Quit
10.et依赖以下哪项技术实现跨语言互用性?(C)
 A. CLR
 B.CTS
 C.CLS
 D.CTT
11.请问: StringStringBuilder类与类有什么区别?为什么
在Net类库中要同时存在这2个类?(简答)
如果要操作一个不断增长的字符串,尽量不用 String类改
用 StringBuilder类。两个类的工作原理不同String类是一种
传统的修改字符串的方式,它确实可以完成把一个字符串
添加到另一个字符串上的工作没错但是在NET框架下,这
个操作实在是划不来。因为系统先是把两个字符串写入内
存,接着删除原来的String对象,然后创建一个 String对象,
并读取内存中的数据赋给该对象。这一来二去的,耗了不
少时间。而使用 SystemText命名空间下面的 StringBuilder类
就不是这样了,它提供的 Append方法,能够在已有对象的
原地进行字符串的修改,简单而且直接。当然,一般情况
下觉察不到这二者效率的差异,但如果你要对某个字符串
进行大量的添加操作,那么 StringBuilder类所耗费的时间和
 String类简直不是一个数量级的。
12以下哪个类是int的基类?(B)
 A. Int32 B.Object C. ValueType  D.Int16
13.以下哪些可以作为接口成员?(多选)(ABDE)
A.方法B.属性C.字段D事件E索引器
F构造函数G析构函数
14.以下关于ref和out的描述哪些项是正确的?(多选)(ACD)
A.使用ref参数,传递到ref参数的参数必须最先初始化。
B.使用out参数,传递到out参数的参数必须最先初始化。
C.使用ref参数,必须将参数作为ref参数显式传递到方法。
D.使用out参数,必须将参数作为out参数显式传递到方法。
15“访问范围限定于此程序或那些由它所属的类派生的类型”是对以下哪个成员可访问性含义的正确描?(B)
 A. public B. protected
 C.internal
 D. protected  internal
16.class Classl
{
 private static int count 0;
 static Class10(){ count++;}
 public Class10{ count++:}
}
Classl ol =new Class10:
Classl o2 =new Class10:
请问,o1 Count的值是多少?(C)
A.1 B.2 c.3 d.4
24.现在需要您写一个数据库连接字符串,连接AllWin上 SQL SERVER中的一个名为 PubBase实例的Test库。
请问,应该选择下面哪一个字符串?(B)
 A."Server=AllWin; Data Source=PubBase; Initial Catalog=Test; Integrated Security=SSPI"
 B."Server= AllWin; Data Source=PubBase; Database=Test; Integrated Security= SSPI'
 C."Data Source= AllWin\PubBase; Initial Category=PubBase; Integrated Security= SSPI'
 D."Data Source= AllWin PubBase; Database=Test; Integrated Security= SSPI"
7.某一密码仅使用K、L、M、N、O共5个字母,密码中的单词从左向右排列,密码单词必须遵循如下规则:
(1)密码单词的最小长度是两个字母,可以相同,也可以不同
(2)K不可能是单词的第一个字母
(3)如果L出现,则出现次数不止一次
(4)M不能使最后一个也不能是倒数第二个字母
(5)K出现,则N就一定出现
(6)O如果是最后一个字母,则L一定出现
问题一:下列哪一个字母可以放在LO中的O后面,形成一个3个字母的密码单词?
 A)K B)L C)M D)N
答案B
问题二:如果能得到的字母是K、L、M,那么能够形成的两个字母长的密码单词的总数是多少?
A)1个B)3个C)6个D)9个
答案A
问题三:下列哪一个是单词密码?
 A)KLLN B)LOML C)MLLO D)NMKO
答案C
